<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Canvas Alphabet Trainer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
            background-color: #F9F7F1; /* Warm paper background */
            touch-action: none; /* Prevent browser zooming/swiping */
            font-family: 'Courier New', Courier, monospace; /* Monospace for technical feel, or system if unavailable */
        }

        /* Hidden input for keyboard on mobile */
        #hidden-input {
            position: absolute;
            opacity: 0;
            top: -1000px;
            left: -1000px; 
            font-size: 16px; 
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .btn {
            pointer-events: auto;
            background-color: #2D2D2D; /* Dark Charcoal */
            color: #F9F7F1;
            border: 3px solid #2D2D2D;
            padding: 1rem 2.5rem;
            border-radius: 0; /* Sharp edges */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 1.2rem;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            box-shadow: 6px 6px 0px rgba(0,0,0,0.15); /* Hard shadow */
            transition: transform 0.1s, box-shadow 0.1s;
            display: none;
            margin-top: 220px;
        }
        
        .btn:active { 
            transform: translate(2px, 2px);
            box-shadow: 4px 4px 0px rgba(0,0,0,0.15);
        }
        
        .btn.visible { display: block; }
        
        @media (max-height: 600px) {
            .btn { margin-top: 160px; padding: 0.8rem 1.5rem; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <input type="number" id="hidden-input" pattern="[0-9]*" inputmode="numeric">
    <div id="ui-layer">
        <button id="main-btn" class="btn">START</button>
    </div>

<script>
    /**
     * CONFIGURATION
     */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const hiddenInput = document.getElementById('hidden-input');
    const mainBtn = document.getElementById('main-btn');

    // Artistic Palette
    const COLORS = {
        bg: '#F9F7F1',      // Warm White
        card: '#FFFFFF',    // Pure White
        ink: '#2D2D2D',     // Charcoal (Text/Outlines)
        accent: '#FF6B6B',  // Coral Red (Timer/Highlights)
        success: '#4ECDC4', // Teal
        error: '#FF6B6B',   // Red
        grid: '#E5E0D8'     // Subtle Grid
    };

    const STATE = { MENU: 0, PLAYING: 1, GAMEOVER: 2 };

    let gameState = STATE.MENU;
    let width, height, dpr;
    
    // Gameplay
    let currentLetter = 'A';
    let currentStreak = 0;
    let highScore = parseInt(localStorage.getItem('canvas-alpha-score') || '0');
    let timeLeft = 3000;
    const TIME_LIMIT = 3000;
    let lastTime = 0;
    let messageText = "";
    let messageColor = COLORS.ink;
    let letterScale = 1;
    
    // Visual Elements
    let particles = [];
    let backgroundElements = [];

    /**
     * INIT & RESIZE
     */
    function init() {
        resize();
        window.addEventListener('resize', resize);
        
        // Initialize Background Art Elements
        for(let i=0; i<8; i++) {
            backgroundElements.push({
                char: Math.random() > 0.5 ? String.fromCharCode(65 + Math.floor(Math.random()*26)) : Math.floor(Math.random()*26).toString(),
                x: Math.random() * width,
                y: Math.random() * height,
                vx: (Math.random() - 0.5) * 0.2,
                vy: (Math.random() - 0.5) * 0.2,
                size: 50 + Math.random() * 150,
                rotation: Math.random() * Math.PI * 2,
                vRot: (Math.random() - 0.5) * 0.002,
                opacity: 0.03 + Math.random() * 0.05
            });
        }
        
        requestAnimationFrame(loop);
    }

    function resize() {
        dpr = window.devicePixelRatio || 1;
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.scale(dpr, dpr);
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
    }

    /**
     * INPUT
     */
    canvas.addEventListener('mousedown', (e) => handleInputFocus(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', (e) => {
        handleInputFocus(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive: false});

    function handleInputFocus(x, y) {
        if (gameState !== STATE.PLAYING) return;
        // Hitbox for input area
        if (Math.abs(y - (height/2 + 60)) < 60) hiddenInput.focus();
    }

    mainBtn.addEventListener('click', () => {
        if (gameState !== STATE.PLAYING) startGame();
    });

    hiddenInput.addEventListener('input', (e) => {
        if (gameState !== STATE.PLAYING) { hiddenInput.value = ''; return; }

        const valStr = e.target.value;
        const valNum = parseInt(valStr);
        const correctVal = currentLetter.charCodeAt(0) - 64;

        if (isNaN(valNum)) return;

        if (valNum === correctVal) {
            triggerSuccess();
        } else if ((valStr.length >= 2 && valNum !== correctVal) || 
                   (correctVal < 10 && valStr.length === 1 && valNum !== correctVal) || 
                   (valNum > 26)) {
            triggerFail(correctVal);
        }
    });

    /**
     * GAME LOGIC
     */
    function startGame() {
        gameState = STATE.PLAYING;
        currentStreak = 0;
        mainBtn.classList.remove('visible');
        hiddenInput.value = '';
        hiddenInput.focus();
        generateLetter();
    }

    function generateLetter() {
        let randomNum = Math.floor(Math.random() * 26);
        let newLetter = String.fromCharCode(65 + randomNum);
        while (newLetter === currentLetter) {
            randomNum = Math.floor(Math.random() * 26);
            newLetter = String.fromCharCode(65 + randomNum);
        }
        currentLetter = newLetter;
        timeLeft = TIME_LIMIT;
        hiddenInput.value = '';
        letterScale = 0.5; // Start small for pop-in
        messageText = "";
    }

    function triggerSuccess() {
        currentStreak++;
        if (currentStreak > highScore) {
            highScore = currentStreak;
            localStorage.setItem('canvas-alpha-score', highScore);
        }
        createParticles(width/2, height/2, COLORS.success);
        generateLetter();
    }

    function triggerFail(correctAnswer) {
        messageText = `${currentLetter} is ${correctAnswer}`;
        messageColor = COLORS.error;
        endGame();
    }

    function endGame() {
        gameState = STATE.GAMEOVER;
        mainBtn.innerText = "PLAY AGAIN";
        mainBtn.classList.add('visible');
        hiddenInput.blur();
    }

    /**
     * PARTICLES
     */
    function createParticles(x, y, color) {
        for(let i=0; i<15; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 12,
                vy: (Math.random() - 0.5) * 12,
                life: 1.0,
                color: Math.random() > 0.5 ? color : COLORS.ink, // Mix with black confetti
                size: Math.random() * 8 + 4,
                type: Math.random() > 0.5 ? 'rect' : 'circle',
                rotation: Math.random() * Math.PI
            });
        }
    }

    function updateAndDrawParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx; p.y += p.vy;
            p.life -= 0.04;
            p.rotation += 0.1;
            
            if (p.life <= 0) { particles.splice(i, 1); continue; }

            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation);
            
            if (p.type === 'rect') {
                ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
            } else {
                ctx.beginPath();
                ctx.arc(0, 0, p.size/2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }
        ctx.globalAlpha = 1.0;
    }

    /**
     * DRAWING - ARTISTIC STYLE
     */
    function drawBackground() {
        // 1. Paper texture / Grid
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, width, height);

        // Draw Grid
        ctx.strokeStyle = COLORS.grid;
        ctx.lineWidth = 1;
        const gridSize = 40;
        ctx.beginPath();
        for(let x=0; x<width; x+=gridSize) { ctx.moveTo(x,0); ctx.lineTo(x,height); }
        for(let y=0; y<height; y+=gridSize) { ctx.moveTo(0,y); ctx.lineTo(width,y); }
        ctx.stroke();

        // 2. Floating Typographic Elements
        ctx.save();
        backgroundElements.forEach(el => {
            el.x += el.vx; el.y += el.vy;
            el.rotation += el.vRot;
            
            // Wrap around screen
            if (el.x < -100) el.x = width + 100;
            if (el.x > width + 100) el.x = -100;
            if (el.y < -100) el.y = height + 100;
            if (el.y > height + 100) el.y = -100;

            ctx.translate(el.x, el.y);
            ctx.rotate(el.rotation);
            ctx.fillStyle = COLORS.ink;
            ctx.globalAlpha = el.opacity;
            ctx.font = `bold ${el.size}px sans-serif`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(el.char, 0, 0);
            ctx.rotate(-el.rotation);
            ctx.translate(-el.x, -el.y);
        });
        ctx.restore();
        ctx.globalAlpha = 1.0;
    }

    function drawHardShadowRect(x, y, w, h) {
        // Hard Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.fillRect(x + 10, y + 10, w, h);
        
        // Main Box
        ctx.fillStyle = COLORS.card;
        ctx.fillRect(x, y, w, h);
        
        // Stroke
        ctx.strokeStyle = COLORS.ink;
        ctx.lineWidth = 3;
        ctx.strokeRect(x, y, w, h);
    }

    function drawGame(dt) {
        const cardW = Math.min(width * 0.85, 380);
        const cardH = 480;
        const cardX = (width - cardW) / 2;
        const cardY = (height - cardH) / 2;
        const cx = width / 2;
        const cy = height / 2;

        drawHardShadowRect(cardX, cardY, cardW, cardH);

        // Stats Header
        ctx.font = "bold 12px 'Courier New', monospace";
        ctx.fillStyle = "#888"; // Lighter grey for labels
        ctx.textAlign = "center";
        ctx.fillText("STREAK", cx - 70, cardY + 50);
        ctx.fillText("BEST", cx + 70, cardY + 50);

        ctx.font = "bold 24px sans-serif";
        ctx.fillStyle = COLORS.ink;
        ctx.fillText(currentStreak, cx - 70, cardY + 75);
        ctx.fillText(highScore, cx + 70, cardY + 75);

        // Timer Ring
        const radius = 60;
        const progress = Math.max(0, timeLeft / TIME_LIMIT);
        
        // Timer Background Ring
        ctx.beginPath();
        ctx.arc(cx, cy - 30, radius + 15, 0, Math.PI*2);
        ctx.strokeStyle = "#eee";
        ctx.lineWidth = 10;
        ctx.stroke();

        // Timer Active Ring
        ctx.beginPath();
        ctx.arc(cx, cy - 30, radius + 15, -Math.PI/2, -Math.PI/2 + (Math.PI*2 * progress));
        ctx.strokeStyle = progress < 0.25 ? COLORS.error : COLORS.accent;
        ctx.lineWidth = 10;
        ctx.stroke();

        // Decorative Ticks on Timer
        ctx.save();
        ctx.translate(cx, cy-30);
        ctx.strokeStyle = COLORS.ink;
        ctx.lineWidth = 2;
        for(let i=0; i<12; i++) {
            ctx.rotate(Math.PI/6);
            ctx.beginPath();
            ctx.moveTo(0, radius + 22);
            ctx.lineTo(0, radius + 26);
            ctx.stroke();
        }
        ctx.restore();

        // The Letter
        ctx.save();
        ctx.translate(cx, cy - 30);
        ctx.scale(letterScale, letterScale);
        ctx.font = "900 100px sans-serif"; // Heavier weight
        ctx.fillStyle = COLORS.ink;
        ctx.textBaseline = "middle";
        ctx.fillText(currentLetter, 0, 5);
        ctx.restore();

        // Input Line
        const boxY = cy + 80;
        ctx.beginPath();
        ctx.moveTo(cx - 50, boxY + 20);
        ctx.lineTo(cx + 50, boxY + 20);
        ctx.strokeStyle = document.activeElement === hiddenInput ? COLORS.accent : '#CCC';
        ctx.lineWidth = 4;
        ctx.stroke();

        // User Input
        ctx.font = "bold 40px 'Courier New', monospace";
        ctx.fillStyle = COLORS.ink;
        ctx.fillText(hiddenInput.value, cx, boxY + 10);

        // Feedback Text
        if (messageText) {
            ctx.font = "bold 16px sans-serif";
            ctx.fillStyle = messageColor;
            ctx.fillText(messageText, cx, boxY + 50);
        } else {
             // Subtle hint
             ctx.font = "italic 14px serif";
             ctx.fillStyle = "#AAA";
             ctx.fillText("type value...", cx, boxY + 50);
        }
    }

    function drawMenu() {
        const cx = width / 2;
        const cy = height / 2;
        const cardW = Math.min(width * 0.85, 380);
        const cardH = 400;
        
        drawHardShadowRect((width - cardW)/2, (height - cardH)/2, cardW, cardH);

        ctx.fillStyle = COLORS.ink;
        ctx.font = "900 32px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("ALPHABET", cx, cy - 60);
        ctx.fillStyle = COLORS.accent;
        ctx.fillText("MASTERY", cx, cy - 25);

        ctx.font = "16px 'Courier New', monospace";
        ctx.fillStyle = "#666";
        ctx.fillText("A=1  B=2  ...  Z=26", cx, cy + 20);
        
        mainBtn.classList.add('visible');
        mainBtn.innerText = "START";
    }

    function drawGameOver() {
        const cx = width / 2;
        const cy = height / 2;
        const cardW = Math.min(width * 0.85, 380);
        const cardH = 450;

        drawHardShadowRect((width - cardW)/2, (height - cardH)/2, cardW, cardH);

        ctx.fillStyle = COLORS.error;
        ctx.font = "900 36px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("TIME'S UP", cx, cy - 80);

        ctx.fillStyle = COLORS.ink;
        ctx.font = "bold 14px 'Courier New', monospace";
        ctx.fillText("FINAL SCORE", cx, cy - 40);

        ctx.font = "900 80px sans-serif";
        ctx.fillStyle = COLORS.ink;
        ctx.fillText(currentStreak, cx, cy + 30);
        
        // Hint at correct answer if lost
        if (messageText) {
            ctx.font = "bold 16px sans-serif";
            ctx.fillStyle = COLORS.error;
            ctx.fillText(messageText, cx, cy + 70);
        }

        mainBtn.classList.add('visible');
        mainBtn.innerText = "RETRY";
    }

    function loop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = timestamp - lastTime;
        lastTime = timestamp;

        drawBackground();

        if (gameState === STATE.PLAYING) {
            timeLeft -= dt;
            if (timeLeft <= 0) { timeLeft = 0; triggerFail(currentLetter.charCodeAt(0) - 64); }
            if (letterScale < 1) { letterScale += 0.08; if (letterScale > 1) letterScale = 1; }
            drawGame(dt);
        } else if (gameState === STATE.MENU) {
            drawMenu();
        } else if (gameState === STATE.GAMEOVER) {
            drawGameOver();
        }

        updateAndDrawParticles();
        requestAnimationFrame(loop);
    }

    // Start
    init();

</script>
</body>
</html>